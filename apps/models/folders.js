// Generated by CoffeeScript 1.3.3
var Files, FilesSchema, Folders, FoldersSchema, ObjectId, Schema, async, f, fSort, fs, log, models, mongoose, path, __;

mongoose = require('mongoose');

Schema = mongoose.Schema;

ObjectId = mongoose.Types.ObjectId;

log = function(){};

models = require('./index');

fs = require('fs');

path = require('path');

__ = require('../i18n');

async = require('async');

FilesSchema = new Schema({
  name: {
    type: String,
    required: true
  },
  type: {
    type: String
  }
}, {
  _id: false
});

FoldersSchema = new Schema({
  name: {
    type: String,
    index: {
      unique: true
    }
  },
  files: [FilesSchema],
  createdUser: String,
  createdDate: Date,
  updatedUser: String,
  updatedDate: Date
}, {
  _id: false
});

FoldersSchema.virtual('path').get(function() {
  return path.join(this.block.path, this.name);
});

FoldersSchema.virtual('block').get(function() {
  if (!(this._block != null)) {
    this._block = models.blocks(this.name);
  }
  return this._block;
});

FoldersSchema.virtual('src').set(function(v) {
  this.name = path.basename(v);
  return this._src = new resources(v);
});

FoldersSchema.virtual('src').get(function() {
  if (!(this._src != null)) {
    this._src = new resources(this.path);
  }
  return this._src;
});

FoldersSchema.virtual('target').set(function(v) {
  return this._target = new resources(v);
});

FoldersSchema.virtual('target').get(function() {
  if (!(this._target != null)) {
    this._target = new resources(this.path);
  }
  return this._target;
});

/*
スキーマメソッドの定義
*/


FoldersSchema.method({});

/*
middlewareの定義
*/


/*
ドキュメント保存時、フォルダが存在していない場合は作成する。
srcPathが存在している場合はそれを移動する。
*/


FoldersSchema.pre('save', function(next) {
  var infoJSON;
  this.files.sort(fSort);
  this.block.make();
  if (this.src.exists()) {
    if (this.src.isDirectory()) {
      this.src.move(this.path);
    } else {
      this.target.make();
      this.src.move(path.join(this.path, this.name));
    }
  }
  this.src = this.path;
  infoJSON = JSON.stringify(this.toJSON());
  return fs.writeFile(this.src.info.path, infoJSON, configs.encode, function() {
    return typeof next === "function" ? next() : void 0;
  });
});

/*
論理フォルダ削除時は物理フォルダも削除する
infoファイルがある場合、一緒に削除される
*/


FoldersSchema.pre('remove', function(next) {
  this.src.remove();
  if (this.block.count() < 1) {
    this.block.remove();
  }
  return typeof next === "function" ? next() : void 0;
});

Files = mongoose.model('Files', FilesSchema);

Folders = mongoose.model('Folders', FoldersSchema);

f = function(name) {
  var file, fileList, fileName, folder, folderName, infoJSON, infoStrings, key, value, _i, _j, _len, _len1;
  folderName = fs.basename(name);
  folder = new Folders({
    src: srcPath
  });
  if (folder.src.info.exists()) {
    infoStrings = fs.readFileSync(folder.src.info.path, configs.encode);
    try {
      infoJSON = JSON.parse(infoStrings);
    } catch (err) {
      infoJSON = {};
    }
    for (value = _i = 0, _len = infoJSON.length; _i < _len; value = ++_i) {
      key = infoJSON[value];
      folder.set(key, value);
    }
  }
  if (folder.src.exists()) {
    folder.files = [];
    if (folder.src.isDirectory()) {
      fileList = fs.readdirSync(folder.src.path);
      for (_j = 0, _len1 = fileList.length; _j < _len1; _j++) {
        fileName = fileList[_j];
        if (fileName === configs.folders.info) {
          continue;
        }
        file = new Files({
          name: fileName,
          type: path.extname(fileName)
        });
        folder.files.push(file);
      }
    } else {
      file = new Files({
        name: folder.name,
        type: path.extname(folder.name)
      });
      folder.files.push(file);
    }
    folder.files.sort(fSort);
  }
  return folder;
};

/*
物理フォルダすべてに対して処理を行う。
区画直下にあるファイルや空フォルダはついでに処理する
*/


Folders.physicalFolders = function(fn, next) {
  return Folders.blockFolders(function(blockPath, nextFn) {
    return Folders.processFolders(blockPath, fn, nextFn);
  }, next);
};

/*
区画フォルダすべてに対して処理を行う。
直下にあるファイルや空フォルダはついでに処理する
*/


Folders.blockFolders = function(fn, next) {
  return Folders.processFolders(configs.folders.fexy, fn, next);
};

/*
指定したフォルダ配下に対してすべて処理を行う
*/


Folders.processFolders = function(parentPath, fn, next) {
  var tasks;
  tasks = [];
  return fs.readdir(parentPath, function(err, folders) {
    var folder, folderPath, _i, _len;
    for (_i = 0, _len = folders.length; _i < _len; _i++) {
      folder = folders[_i];
      folderPath = path.join(parentPath, folder);
      tasks.push(Folders.processFolder(folderPath, fn));
    }
    return async.parallel(tasks, function(err, results) {
      return typeof next === "function" ? next(null, results) : void 0;
    });
  });
};

/*
フォルダに処理を行う
基本的に内部処理用
*/


Folders.processFolder = function(folderPath, fn) {
  return function(next) {
    var folder, streamPath;
    if (fs.statSync(folderPath).isFile()) {
      streamPath = path.join(configs.folders.upstream, block);
      log("[Folders.physicalFolders]Moving file on fexy : " + folderPath + " : " + streamPath);
      return fs.rename(blockPath, streamPath, typeof next === "function" ? next() : void 0);
    } else {
      folder = Folders.newFolder(folderPath);
      if (folder.count < 1) {
        log("[Folders.physicalFolders]Removing physical folder : " + folderPath);
        return folder.remove(next);
      } else {
        return fn(folderPath, next);
      }
    }
  };
};

/*
ファイル一覧を名前順に並べる
*/


fSort = function(a, b) {
  if (a.name > b.name) {
    return 1;
  }
  if (a.name < b.name) {
    return -1;
  }
  return 0;
};

module.exports = Folders;
